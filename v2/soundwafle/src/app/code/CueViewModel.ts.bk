// /// <reference path="./../typings/github-electron/github-electron.d.ts" />
// /// <reference path="./../typings/jquery/jquery.d.ts" />
// /// <reference path="./../typings/knockout/knockout.d.ts" />
// /// <reference path="AudioPlayer.ts" />
// /// <reference path="ShowFile.ts" />

// let $: JQueryStatic = require('jquery');
// let ko: KnockoutStatic = require('knockout');
 const path = require('path');
 import {Observable, BehaviorSubject} from 'rxjs';
 import {faPause} from '@fortawesome/angular-fontawesome'


 enum CurrentState {
    Playing,
    Paused,
    Stopped,
}


// should consider making CueVM and PlaylistCueVM one and the same? Isn't a single cue,just a playlist with one song?
 abstract class BaseCueViewModel {

    protected playIcon = 'fa-play';
    protected player: HTMLAudioElement = new Audio();
    protected state = new BehaviorSubject(CurrentState.Stopped);
    protected loop = new BehaviorSubject(false);
    protected volume = new BehaviorSubject((100);
    protected displayName = new BehaviorSubject<string>('');
    protected fileName = new BehaviorSubject<string>('');
    protected icon = new BehaviorSubject<string>(this.playIcon);
    protected fadeTime = new BehaviorSubject<number>(1);
    protected progress = new BehaviorSubject<number>(0);
    protected progressNormalize = new BehaviorSubject(0);
    protected src = new BehaviorSubject<string>('');
    pause = faPause;

    constructor(loop: boolean = false, volume: number = 100, fadeTime: number = 1.0) {

        this.loop.subscribe((newVal) => {
            this.setLoop(newVal);
            // this.player.loop = newVal;
        });

        this.volume.subscribe((newValue) => {
            if (this.player) {
                this.player.volume = newValue / 100;
            }
        });

        this.state.subscribe((newValue) => {
            if (newValue === CurrentState.Playing) {
                this.icon('fa-pause');
            } else if (newValue === CurrentState.Paused || newValue === CurrentState.Stopped) {
                this.icon(this.playIcon);
            } else {
                // this.icon("fa-stop");
            }
        });

        this.player.onended = () => {
            this.onEnd();
        };

        this.loop(loop);
        this.volume(volume);
        this.fadeTime(fadeTime);

        this.player.ontimeupdate = (ev: Event) => {
            this.progress(this.player.currentTime / this.player.duration);
            this.progressNormalize(this.progress() * 100);

        };

        this.src.subscribe((val) => {
            this.player.src = val;
        });


    }

    get IsPlaying() {
        return this.state() === CurrentState.Playing;
    });

    onEnd(): void {
		this.state.next(CurrentState.Stopped);
	}

    setLoop(newVal: boolean) { }

    public fade() {
        this.fadeOut(this.fadeTime() * 1000);
    }

    fadeOut(timeMs: number) {
        $(this.player).animate({ volume: 0.0 }, {
            duration: timeMs,
            done: () => {
                this.stop();
            }// ,
        });
    }

    stop() {
        this.player.pause();
        const e: HTMLAudioElement = this.player;
        e.currentTime = 0;
        this.state(CurrentState.Stopped);
    }

    isPaused(): boolean {
        return this.state() === CurrentState.Paused;
    }

    isStopped(): boolean {
        return this.state() === CurrentState.Stopped;
    }

    public play() {
        if (this.isStopped() || this.isPaused()) {
            this.playCurrent();
        } else {
            this.player.pause();
            this.state(CurrentState.Paused);
        }
    }

    protected playCurrent() {
        this.player.volume = this.volume() / 100;
        this.player.play();
        this.state(CurrentState.Playing);
    }

    save(cue: ICue) {
        cue.loop = this.loop();
        cue.volume = this.volume();
        cue.fadeTime = this.fadeTime();
    }
}

 class CueViewModel extends BaseCueViewModel {

    constructor(f: string, loop: boolean = false, volume: number = 100, fadeTime: number = 1) {
        super(loop, volume, fadeTime);
        this.src(f);
        this.fileName(f);
        this.displayName(path.basename(this.fileName()));
    }

    save(cue: ICue) {
        cue.fileName = this.fileName();
        super.save(cue);
    }

    setLoop(newVal: boolean) {
        this.player.loop = newVal;
    }
}


 class PlaylistCueViewModel extends BaseCueViewModel {

    private files: KnockoutObservableArray<string> = new BehaviorSubjectArray([]);
    private currentIndex = 0;
    private playlistCount: number;
    private shuffle: KnockoutObservable<boolean> = new BehaviorSubject(false);

    private history: number[] = [];

    constructor(files: string[], loop: boolean = false, shuffle: boolean = false, volume: number = 100, fadeTime: number = 1) {
        super(loop, volume, fadeTime);

        if (files) {
            files.forEach((file) => {
                this.files.push(file);
            });

            if (this.files && this.files().length > 0) {
                this.setCurrentPlayFile(0);
            }
        }

        this.shuffle(shuffle);
    }

    getDisplayString(file: string): string {
        return path.basename(file);
    }

    playAt(index: number) {
        this.setCurrentPlayFile(index);
        console.log('Play At: ', index);
        this.history.push(index);
        this.play();
    }

    isPlaying(data) {
        return data === this.src() && this.state() === CurrentState.Playing;
    }

    setCurrentPlayFile(index: number) {
        const file = this.files()[index];
        this.fileName(file);

        if (!(this.src().indexOf(file) > -1)) {
            this.state(CurrentState.Stopped);
            this.src(file);

            this.displayName(path.basename(this.fileName()));
        }

        this.playlistCount = this.files().length;
    }

    removeItem(index: number) {
        this.files().splice(index, 1);
    }

    onEnd(): void {

        let atEnd = false;

        if (this.shuffle()) {

            atEnd = this.history.length >= this.playlistCount;

            if (atEnd) {
                this.history = [];
            }

            this.currentIndex = this.getNewRandomIndex();

        } else {
            atEnd = this.currentIndex === this.playlistCount - 1;

            if (atEnd) {
                this.currentIndex = 0;
            }
        }

        if (atEnd && !this.loop()) {
            this.src('');
            return;
        }

        this.setCurrentPlayFile(this.currentIndex);

        this.playAt(this.currentIndex);
    }

    save(cue: IPlayListCue) {
        cue.fileName = [];

        this.files().forEach((file) => {
            (cue.fileName as string[]).push(file);
        });

        cue.shuffle = this.shuffle();
        super.save(cue);
    }

    toggleShuffle() {
        this.shuffle(!this.shuffle());
    }

    inHistory(n: number): boolean {
        let found = false;
        this.history.forEach((value) => {
            if (n === value) {
                found = true;
                return;
            }
        });
        return found;
    }

    getNewRandomIndex(): number {

        let index: number;
        do {

            index = Math.floor((Math.random() * this.playlistCount));

            if (!this.inHistory(index)) {
                break;
            }

        } while (true);

        return index;
    }
}
